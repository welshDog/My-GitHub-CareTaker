# ðŸ› ï¸ Technical Audit Report: CareTaker JS Core

**Date:** October 26, 2025
**Scope:** `caretaker-js/` Directory (Node.js Server)
**Auditor:** Hyper Agent

---

## 1. Executive Summary
The `caretaker-js` server handles high-throughput agent coordination. The review identified concurrency risks in the queue processing logic and potential stability issues with external connections (Redis/GitHub).

---

## 2. Identified Issues & Fixes

### ðŸš¨ Issue 1: Queue Processing Race Condition
**Severity:** High
**Location:** `caretaker-js/server/src/agents.ts`
**Problem:**
The queue processor uses `setInterval` with a 1000ms delay.
```typescript
setInterval(async ()=>{
  const item = await popQueue() // ... logic
}, 1000)
```
If `popQueue()` or the subsequent processing takes longer than 1000ms (e.g., due to Redis latency or heavy load), multiple intervals will overlap. This causes race conditions, double-processing of events, and unpredictable resource usage.

**Corrected Implementation:**
Use a recursive `setTimeout` pattern to ensure one cycle completes before the next begins.

```typescript
// caretaker-js/server/src/agents.ts

async function processQueue() {
  try {
    const item = await popQueue()
    if (item) {
      // ... existing logic ...
    }
  } catch (err) {
    logger.error(err)
  } finally {
    // FIX: Schedule next run only after current one finishes
    setTimeout(processQueue, 1000)
  }
}

// Start the loop
processQueue()
```

---

### ðŸš¨ Issue 2: Unhandled Redis Connection Failures
**Severity:** Critical
**Location:** `caretaker-js/server/src/index.ts`
**Problem:**
The server initializes Redis without an error listener.
```typescript
const redis = new Redis(config.redisUrl)
```
If the Redis server is down or unreachable, the Node.js process will crash with an "Unhandled 'error' event" exception, taking the entire service offline.

**Corrected Implementation:**
Add proper error handling and connection logging.

```typescript
// caretaker-js/server/src/index.ts

const redis = new Redis(config.redisUrl, {
  retryStrategy: (times) => {
    const delay = Math.min(times * 50, 2000);
    return delay;
  }
})

// FIX: Handle connection errors gracefully
redis.on('error', (err) => {
  logger.error({ err }, 'Redis connection error')
})

redis.on('connect', () => {
  logger.info('Redis connected')
})
```

---

### ðŸš¨ Issue 3: GitHub Pagination Infinite Loop Risk
**Severity:** Medium
**Location:** `caretaker-js/server/src/github.ts`
**Problem:**
The pagination loop checks `hasNextPage` but relies on `endCursor` changing.
```typescript
while(true){
  // ... request ...
  if(!page.pageInfo.hasNextPage) break
  after = page.pageInfo.endCursor
}
```
In rare cases, GitHub's API might return `hasNextPage: true` but the same `endCursor`, causing an infinite loop that burns API quota.

**Corrected Implementation:**
Add a safety break or ensure cursor movement.

```typescript
// caretaker-js/server/src/github.ts

let after: string | undefined
const nodes: any[] = []
let safetyCounter = 0
const MAX_PAGES = 100 // Safety limit

while(safetyCounter < MAX_PAGES){
  // ... request ...
  
  if(!page.pageInfo.hasNextPage) break
  
  // FIX: Prevent infinite loop if cursor doesn't change
  if(after === page.pageInfo.endCursor) break
  
  after = page.pageInfo.endCursor
  safetyCounter++
}
```

---

## 3. Testing Procedures

### Load Test for Queue
Simulate slow processing logic (sleep 2000ms) inside the queue handler.
*   **Old Code:** Will spawn new handlers every 1s, leading to pile-up.
*   **New Code:** Will wait 2s + 1s, effectively running every 3s, maintaining stability.

### Chaos Test for Redis
Start the server, then kill the Redis container (`docker stop redis`).
*   **Old Code:** Server crashes immediately.
*   **New Code:** Server logs errors but stays alive; reconnects when Redis returns.

---

## 4. Preventive Measures
1.  **Concurrency Patterns:** Ban `setInterval` for async tasks; enforce `setTimeout` loops.
2.  **Resilience Testing:** Add "Chaos Monkey" tests in CI that kill dependent services (Redis/DB).
3.  **Linting**: Use `eslint-plugin-promise` to catch unhandled promise rejections.

---
*Report generated by Hyper Agent ðŸ¤–*
